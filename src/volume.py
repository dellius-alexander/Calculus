from sympy import symbols, sqrt, init_printing, Integral, pretty_print, pretty, exp, pi, sin, \
    print_latex, simplify, solve, expand, latex, cos
import net_change as nc
import areas as ar
from fractions import Fraction
import numpy as np
import webbrowser
import sys
import os
from mpmath import e
from IPython.core.display import display, HTML, Math

init_printing(use_unicode=True)


#####################################################################
#                   Display Object
#####################################################################
def _display_(_obj_=object):
    """Display latex objects in generated webpage.

    :param _obj_: the latex vector
    :return:
    """
    html = ("""
            <!DOCTYPE html>
            <html>
                <head>
                  <meta charset="utf-8">
                  <meta name="viewport" content="width=device-width">
                  <title>MathJax example</title>
                  <script id="MathJax-script" async 
                  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
                                
                </head>
                <body>
                    <p>                        
                        {0}
                    </p>
                </body>                
            </html>""".format(_obj_))
    path = os.path.abspath('temp.html')
    url = 'file://' + path
    with open(path, 'w') as _file_:
        _file_.write(html)
    webbrowser.open(url)


#####################################################################
#####################################################################
#             Volume of Rectangular Prism
#####################################################################
def _rec_prism_(length, width, height) -> object:
    """Volume of a Rectangular Prism:

    V = lwh = length  width  height
    SA = 2lw * 2hw * 2lh
    SA = 2(length * width) + 2(height * width) + 2(length * height)
    
    :param length:
    :param width:
    :param height:
    :return:
    """
    _volume_ = length * width * height
    _surface_area_ = 2 * (length * width) + 2 * (height * width) + 2 * (length * height)
    return [_volume_, _surface_area_]


#####################################################################
#####################################################################
#                            Volume Using Disks 1
#####################################################################
def _volume_disk_(fx, lower_bound, upper_bound, variable_of_integration) -> object:
    """The Disk Method:
If a region in the plane is revolved about a line in the same
plane, the resulting vector is known as a solid of revolution.
For example, a solid right circular cylinder can be generated by
revolving a rectangle. Similarly, a solid spherical ball can be
generated by revolving a semi-disk. The line about which we
rotate the shape is called the axis of revolution.
The disk method is used when we rotate a single curve v2 = f(v1)
around the v1 or v2 axis. Suppose that v2 = f(v1) is a continuous
non-negative function on the interval [a, b].
The volume of the solid formed by revolving the region bounded by
the curve  v2 - f(v1) and the v1-axis between v1 = a and v1 = b about
the v1-axis is given by:

- V = π ∫ [a,b] [ f(v1) ]^2 dx

The cross section perpendicular to the axis of revolution has
the form of a disk of radius R = f(v1).
Similarly, we can find the volume of the solid when the region
is bounded by the curve v1 = f(v2) and the v2-axis between v2 = c
and v2 = d, and is rotated about the v2-axis. The resulting formula is:

- V = π ∫ [c, d] [ f(v2)]^2 dy

    :param fx: f(v1) is the function on the interval
    :param lower_bound:
    :param upper_bound:
    :param variable_of_integration:
    :return:
    """
    r = fx
    a = lower_bound
    b = upper_bound
    _v_ = variable_of_integration
    c, d = symbols('c, d')
    _area_ = ar.circle_(r)
    _integral_ = Integral(_area_, (_v_, c, d))
    _integral_sol = Integral(_area_, (_v_, a, b))
    _solution_ = _integral_sol.doit()

    print("\nVolume of the region, Integral notation: \n")
    pretty_print(_integral_sol)
    print('\nThe antiderivative of the function with respect to {} is:\n'.format(_v_))
    pretty_print(_integral_.doit())
    print('\nVolume of the region is : \n')
    pretty_print(_solution_)


#####################################################################
#####################################################################
#     Volume Using Washers 1 - Around the v1-Axis
#####################################################################
def _volume_washer_(fx, gx, lower_bound, upper_bound, variable_of_integration) -> object:
    """ The washer method:

If a region in the plane is revolved about a line in the same plane,
the resulting vector is known as a solid of revolution. For example,
a solid right circular cylinder can be generated by revolving a rectangle.
Similarly, a solid spherical ball can be generated by revolving a semi-disk.
The line about which we rotate the shape is called the axis of revolution.
We can extend the disk method to find the volume of a hollow solid of revolution.
Assuming that the function f(v1) and g(v1) are continuous and non-negative on
the interval [a,b] and g(v1) ≤ f(v1),  consider a region that is bounded
by two curves v2 = f(v1) and v2 = g(v1), between v1 = a and v1 = b.
The volume of the solid formed by revolving the region about the
v1−axis is:

- V = π ∫ [a,b] ( [f(v1)]^2 − [g(v1)]^2 ) dx

At a point v1 on the v1−axis, a perpendicular cross section of the
solid is washer-shape with the inner radius r = g(v1) and the outer radius
R = f(v1). The volume of the solid generated by revolving about the v2−axis
a region between the curves v1 = f(v2) and v1 = g(v2), where g(v2) ≤ f(v2) and
c ≤ v2 ≤ d  is given by the formula:

- V = π ∫ [c,d] ( [f(v2)]^2 − [g(v2)]^2 ) dy

    :param fx: f(v1) is the top curve
    :param gx: g(v1) is the bottom curve
    :param lower_bound:
    :param upper_bound:
    :param variable_of_integration:
    :return:
    """
    a, b = symbols('a, b')
    _a_ = lower_bound
    _b_ = upper_bound
    _v_ = variable_of_integration
    if str(_v_) == "v1":
        _l_ = "a"
        _u_ = "b"
    elif str(_v_) == "v2":
        _l_ = "c"
        _u_ = "d"
    fx_area = ar.circle_(fx)
    gx_area = ar.circle_(gx)
    demo = Integral((fx_area - gx_area), (_v_, _l_, _u_))
    vol = Integral((fx_area - gx_area), (_v_, _a_, _b_))
    int_vol = vol.doit()
    print('\nf(v1) = \n{0}'.format(pretty(fx)))
    print('\ng(v1) = \n{0}'.format(pretty(gx)))
    print('\nArea of f(v1) = \n')
    pretty_print(fx_area)
    print('\nArea of g(v1) = \n')
    pretty_print(gx_area)
    print('\nIntegrate the Area of [ A(f({0})) - A(g({0})) ], over the bounds of '
          '{1} = {2} & {3} = {4}: \n'.format(_v_, _l_, _a_, _u_, _b_))
    pretty_print(demo)
    print('\nIntegrate the Area of [ A(f({0})) - A(g({0})) ], over the bounds of '
          '{1} = {2} & {3} = {4}: \n'.format(_v_, _l_, _a_, _u_, _b_))
    pretty_print(vol)
    print('\nFind the antiderivative of integration: \n')
    pretty_print(demo.doit())
    print('\nSolve for the volume over the bounded region R: \n')
    pretty_print(int_vol)


#####################################################################
#     Volumes by Cylindrical Shells: the Shell Method
#####################################################################
def _cylindrical_shell_(fx, gx, lower_bound, upper_bound, line_of_rotation,
                      variable_of_integration) -> object:
    """Volumes by Cylindrical Shells: the Shell Method.

 V = 2πrh Δr
    Another method of find the volumes of solids of revolution is the shell
method. It can usually find volumes that are otherwise difficult to evaluate
using the Disc / Washer method.

- General formula: V = ∫ 2π (shell radius)(shell height) dx

The Shell Method (about the v2-axis)The volume of the solid generated by revolving
about the v2-axis the region between the v1-axis and the graph of a continuous function
v2 = f (v1), a ≤ v1 ≤ b is:

- V = ∫ [a,b] 2π  [radius] * [shell height] dx = ∫ [a,b] 2π * v1 * f(v1) dx

Similarly,

The Shell Method (about the v1-axis) The volume of the solid generated by revolving
about the v1-axis the region between the v2-axis and the graph of a continuous function
v1 = f (v2), c ≤ v2 ≤ d is:

- V = ∫ [c,d] 2π  [radius] * [shell height] dy = ∫ [c,d] 2π * v2 * f(v2) dy

***Note: An easy way to remember which method to use to find the volume of a solid of
revolution is to note that the Disc / Washer method is used if the independent variable
of the function(s) and the axis of rotation is the same (e.g., the area under v2 = f (v1),
revolved about the v1-axis); while the Shell method should be used if the independent
variable is different from the axis of rotation (e.g., the area under v1 = f (v2), revolved
about the v1-axis).

    :param fx:
    :param gx:
    :param lower_bound:
    :param upper_bound:
    :param line_of_rotation:
    :param variable_of_integration:
    :return:
    """
    # noinspection DuplicatedCode
    _l_ = lower_bound
    _u_ = upper_bound
    _var_ = variable_of_integration
    _f_ = fx if fx is not None else gx
    _g_ = gx
    k = line_of_rotation if line_of_rotation is not None else None
    _radius_ = _var_ if k is None else (_var_ - k)
    _k_ = _radius_ if _radius_ is not None else _var_
    if _f_ is not None and _g_ is None:
        if _u_ is None:
            sol = solve(_f_)
            for aa in sol:
                if aa > 0:
                    _u_ = aa
        pretty_print(_u_)
        _v_ = Integral((2 * pi * _k_ * _f_), (_var_, _l_, _u_))
        _demo_ = Integral((2 * pi * _k_ * _f_), _var_)
        _demo_sol = _demo_.doit()
        print("\nIntegral: \n")
        pretty_print(_v_)
        print("\nSolution: \n")
        sol_v = _v_.doit()
        pretty_print(sol_v)
        return [_demo_, _demo_sol, _v_, sol_v]
    elif _f_ is not None and _g_ is not None:
        if _u_ is None:
            sol = solve(_g_ - _f_)
            for aa in sol:
                if aa > 0:
                    _u_ = aa
        pretty_print(_u_)
        _v_ = Integral((2 * pi * _radius_ * (_f_ - _g_)), (_var_, _l_, _u_))
        _demo_ = Integral((2 * pi * _radius_ * (_f_ - _g_)), _var_)
        _demo_sol = _demo_.doit()
        print("\nIntegral: \n")
        pretty_print(_v_)
        print("\nSolution: \n")
        sol_v = _v_.doit()
        pretty_print(sol_v)
        pretty_print(simplify(sol_v))
        return [_demo_, _demo_sol, _v_, sol_v]


#####################################################################
#           Arc Length
#####################################################################
def _arc_length_(fx, gx, lower_bound, upper_bound, line_of_rotation,
               variable_of_integration) -> object:
    """The Arc Length Function:

    If a smooth curve C has the equation v2 = f(v1), a ≤ v1 ≤ b, let s(v1) be the distance along C
    from the initial point P_0(a, f(a)) to the point Q(v1, f(v1)). Then s is a function, called
    the arc length function:

    - Arc Length = ∫ [a,b] √(1 + [f′(v1)]^2)
dx.
    
    :param fx:
    :param gx:
    :param lower_bound:
    :param upper_bound:
    :param line_of_rotation:
    :param variable_of_integration:
    :return:
    """
    # noinspection DuplicatedCode
    _l_ = lower_bound
    _u_ = upper_bound
    _var_ = variable_of_integration
    _f_ = fx if fx is not None else gx
    _g_ = gx
    k = line_of_rotation if line_of_rotation is not None else None
    _radius_ = _var_ if k is None else (_var_ - k)
    _k_ = _radius_ if _radius_ is not None else _var_
    if _f_ is not None and _g_ is None:
        _f_der = _f_.diff(_var_)
        _f_arc = sqrt(1 + _f_der ** 2)
        _f_int = Integral(_f_arc, (_var_, _l_, _u_))
        sol_f_int = simplify(_f_int.doit())
        if isinstance(sol_f_int, float):
            print("simplified Fraction: \n")
            pretty_print(Fraction(sol_f_int).limit_denominator())
        _demo_ = Integral(_f_arc, _var_)
        _demo_sol = _demo_.doit()
        print("\nf'({}) = \n".format(_var_))
        pretty_print(_f_der)
        print("\nArc Length Function: \n")
        pretty_print(_demo_)
        print("\nUnbounded Antiderivative Solution of Arc Length: \n")
        pretty_print(_demo_sol)
        # print("\nArc Length")
        # pretty_print(_f_arc)
        print("\nBounded Arc Length: \n")
        pretty_print(_f_int)
        print("\nBounded Arc Length Solution: \n")
        pretty_print(simplify(sol_f_int))
    return [fx, _f_der, _demo_, _demo_sol, _f_int, sol_f_int]


#####################################################################
#     Area of a Surface of Revolution
#####################################################################
def _surface_area_of_revolution_(fx, gx, lower_bound, upper_bound, line_of_rotation,
                               variable_of_integration) -> object:
    """Area of a Surface of Revolution:

    A surface of revolution is obtained when a curve is rotated about an axis.
    We consider two cases – revolving about the v1−axis and revolving about the
    v2−axis.

    Revolving about the v1−axis:

    Suppose that v2(v1), v2(t), and v2(θ) are smooth non-negative function on the
    given interval.

    A1. If the curve v2 = f(v1), a ≤ v1 ≤ b is rotated about the v1−axis, then the surface
    area is given by:

    - A = 2π ∫ [a, b] f(v1) √(1 + [f′(v1)]^2) dx.

    A2. If the curve is described by the function v1 = g(v2), c ≤ v2 ≤ d, and rotated
    about the v1−axis, then the area of the surface of revolution is given by:

    - A = 2π ∫ [c, d] v2 √(1 + [g′(v2)]^2) dy.

    A3. If the curve defined by the parametric equations v1 = v1(t), v2 = v2(t), with t
    ranging over some interval [α, β], is rotated about the v1−axis, then the surface
    area is given by the following integral (provided that v2(t) is never negative):

    - A = 2π ∫ [α, β] v2(t) √([v1′(t)]^2 + [v2′(t)]^2) dt.

    A4. If the curve defined by polar equation r = r(θ), with θ ranging over some interval
    [α, β], is rotated about the polar axis, then the area of the resulting surface is
    given by the following formula (provided that v2 = r sin θ  is never negative):

    - A = 2π ∫ [α, β] r(θ) sin(θ) √([r(θ)]^2 + [r′(θ)]^2) dθ.

    Revolving about the v2−axis:

    Suppose that g(v2), v1(t), and v1(θ) are smooth non-negative function on the
    given interval.

    B1. If the curve v2 = f(v1), a ≤ v1 ≤ b is rotated about the v2−axis, then the surface
    area is given by:

    - A = 2π ∫ [a, b] v1 √(1 + [f′(v1)]^2) dx.

    B2. If the curve is described by the function v1 = g(v2), c ≤ v2 ≤ d, and rotated
    about the v2−axis, then the area of the surface of revolution is given by:

    - A = 2π ∫ [c, d] g(v2) √(1 + [g′(v2)]^2) dy.

    B3. If the curve defined by the parametric equations v1 = v1(t), v2 = v2(t), with t
    ranging over some interval [α, β], is rotated about the v2−axis, then the surface
    area is given by the following integral (provided that v1(t) is never negative):

    - A = 2π ∫ [α, β] v1(t) √([v1′(t)]^2 + [v2′(t)]^2) dt.

    B4. If the curve defined by polar equation r = r(θ), with θ ranging over some interval
    [α, β], is rotated about v2-axis, then the area of the resulting surface is
    given by the following formula (provided that v1 = r sin θ  is never negative):

    - A = 2π ∫ [α, β] r(θ) cos(θ) √([r(θ)]^2 + [r′(θ)]^2) dθ.

    :param fx:
    :param gx:
    :param lower_bound:
    :param upper_bound:
    :param line_of_rotation:
    :param variable_of_integration:
    :return:
    """
    _l_ = lower_bound
    _u_ = upper_bound
    _var_ = variable_of_integration
    _f_ = fx if fx is not None else gx
    _g_ = gx
    k = line_of_rotation if line_of_rotation is not None else None
    _radius_ = _var_ if k is None else (_var_ - k)
    _k_ = _radius_ if _radius_ is not None else _var_
    if _f_ is not None and _g_ is None:
        _f_der = _f_.diff(_var_)
        _f_arc = simplify(2 * pi * _f_ * sqrt(1 + _f_der ** 2))
        _f_int = Integral(_f_arc, (_var_, _l_, _u_))
        sol_f_int = simplify(_f_int.doit())
        _demo_ = Integral(_f_arc, _var_)
        _demo_sol = _demo_.doit()
        print("\nf({}) = \n".format(_var_))
        pretty_print(_f_)
        print("\nf'({}) = \n".format(_var_))
        pretty_print(_f_der)
        print("\nArc Length Function: \n")
        pretty_print(_demo_)
        print("\nUnbounded Antiderivative Solution of Arc Length: \n")
        pretty_print(_demo_sol)
        # print("\nArc Length")
        # pretty_print(_f_arc)
        print("\nBounded Arc Length: \n")
        pretty_print(_f_int)
        print("\nBounded Arc Length Solution: \n")
        pretty_print(simplify(sol_f_int))
        print(sol_f_int)
        print("\nExpanded Solution: \n")
        pretty_print(expand(sol_f_int))
        return [fx, _f_der, _demo_, _demo_sol, _f_int, sol_f_int]


#####################################################################
#     Mass and Density 1 - Linear Density
#####################################################################
def _linear_density_(px, lower_bound, upper_bound, variable_of_integration) -> object:
    """

    Let R denote a region bounded above by the graph of a continuous function
    f(v1), below by the v1-axis, and on the left and right by the lines v1 = a
    and v1 = b, respectively. Let ρ denote the density of the associated lamina.
    Then we can make the following statements:

    - i. The mass of the lamina is:
        - m = ρ ∫ [a, b] f(v1)dx

    - ii. The moments M_x and M_y of the lamina with respect to the v1-axis and v2-axes,
            respectively, are
        - M_x = ρ ∫ [a, b] [f(v1)]^2/2 dx
        and
        - M_y = ρ ∫ [a, b] v1 f(v1) dx

    - iii. The coordinates of the center of mass ( X̅, y̅ ) are:
        - X̅ = M_y/m  and  y̅ = M_x/m



    :param px:
    :param lower_bound:
    :param upper_bound:
    :param variable_of_integration:
    :return:
    """
    _l_ = lower_bound
    _u_ = upper_bound
    _var_ = variable_of_integration
    _mass_ = Integral(px, (_var_, _l_, _u_))
    _mass_sol_ = _mass_.doit()
    print("\nIntegral mass: \n")
    pretty_print(_mass_)
    print("\nMass of the vector: \n")
    pretty_print(_mass_sol_)
    return [_mass_, _mass_sol_]


#####################################################################
# Mass of a Two-Dimensional Object From Its Radial Density Function
#####################################################################
def _radial_density_(px, radius, variable_of_integration) -> object:
    """

    We need to recall how to calculate the mass of a circular vector
    from its radial density function.

    Let ρ(v1) be an integrable function representing the radial density
    of a disk of radius r. Then the mass of the disk is given by:

    - m = ∫ [0, r] 2π v1 ρ(v1) dx.

    :param px:
    :param radius:
    :param variable_of_integration:
    :return:
    """
    x, b = symbols('v1, b')
    _l_ = 0
    _u_ = radius
    _var_ = variable_of_integration
    _mass_ = Integral(2 * pi * x * px, (_var_, _l_, _u_))
    _demo_ = Integral(2 * pi * x * px, (_var_, _l_, b))
    _mass_sol_ = _mass_.doit()
    print("\nIntegral mass: \n")
    pretty_print(_mass_)
    print("\nMass of the vector: \n")
    pretty_print(_demo_.doit())
    print("\nMass of the vector: \n")
    pretty_print(_mass_sol_)
    return [_mass_, _mass_sol_]

    #####################################################################
    #####################################################################
    #                           Main Method
    #####################################################################


# if __name__ == "__main__":
#     #     # main method
#     v1, v2, t = symbols('v1, v2, t')
#     f = 3 + exp(3*v1**2)
#     g = None
#     # a = 2
#     # b = 6
#     _radius_ = 3
#     _variable_ = v1
#     _radial_density_(f, _radius_, _variable_)
